cameras:
  camera1:
    type: perspective

lights:
  light1:
    type: directional
    direction: [0, 1, -.5]
    diffuse: .3
    ambient: 1

scene:
  background:
    color: black

sources:
  here:
    type: MVT
    url: https://here-traffic-history.herokuapp.com/tiles/{z}/{x}/{y}.mvt
    tile_size: 256
    max_zoom: 16

layers:
  traffic_history:
    data:
      source: here
    draw:
      lines:
        order: 1000
        style: segments

styles:
  segments:
    base: lines
    draw:
      color: red
      width: [[8, 0.5px], [18, 5px]]

    # animated: true
    # texcoords: true
    # shaders:
    #   defines:
    #     # TANGRAM_WORLD_POSITION_WRAP: false
    #     # EFFECT_GRAY: true
    #   uniforms:
    #     u_mouse_x: 0.0
    #     u_mouse_y: 0.0
    #     # u_color: [.5, .5, .5]
    #     u_speed: 2.5
    #   blocks:
    #     # global: |
    #     #   float getGrayscale(vec3 p) { return (p.r + p.g + p.b) / 3.0; }
    #     position: |
    #       position.x += (sin(modelPosition().x + u_time * u_speed) * 10.0 + 2.0);
    #       position.y += (cos(modelPosition().y + u_time * u_speed) * 10.0 + 1.0);
    #     color: |
    #       vec2 mousePos = vec2(u_mouse_x, u_mouse_y) / u_resolution * u_device_pixel_ratio;
    #       // Flip the y axis to match this coordinate system
    #       mousePos.y = 1. - mousePos.y;
    #       // Calculate the normalized position of this fragment/pixel
    #       vec2 fragmentPos = gl_FragCoord.xy / u_resolution;

    #       // Find the distance to the mouse
    #       float mouseDistance = abs(distance(mousePos, fragmentPos));

    #       if (mouseDistance < 0.045) {
    #         color.rgb = vec3(1.00,0.99,0.28);
    #       }

    #       // Set color and alpha
    #       //if (point_dist < centerRingRadius) {
    #       //  color.rgba = vec4(1., 1., 1., 1.);
    #       //} else {
    #       //  color.a = (1. - point_dist);
    #       //}

    #       vec3 pos = worldPosition().xyz*0.01;
    #       color.r *= sin(pos.x + 2.0);
    #       color.g = sin(mousePos.y * mousePos.x);
    #       color.b *= sin(worldPosition().y * 1.5 + 2.0);
